'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

require('angular');

require('angular-mocks');

var _snapshotSerializer = require('./snapshotSerializer');

var _snapshotSerializer2 = _interopRequireDefault(_snapshotSerializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var _window = window,
    angular = _window.angular; // eslint-disable-line no-undef

var render = function render($compile, $scope) {
  return function (html) {
    var element = $compile(html)($scope);
    $scope.$digest();
    return element;
  };
};

var eventually = function eventually($scope) {
  return function (fn, interval, limit) {
    return new Promise(function (resolve, reject) {
      var check = function check() {
        var iteration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        $scope.$digest();
        try {
          resolve(fn());
        } catch (e) {
          if (iteration >= limit) {
            console.warn('[eventually] ' + iteration + ' iteration reached with exception');
            reject(e);
          } else {
            setTimeout(function () {
              return check(iteration + 1);
            }, interval);
          }
        }
      };

      check();
    });
  };
};

expect.addSnapshotSerializer(_snapshotSerializer2.default);

exports.default = function (_ref) {
  var modules = _ref.modules,
      mocks = _ref.mocks,
      access = _ref.access;

  (modules || []).forEach(function (module) {
    return angular.mock.module(module);
  });

  var mockNames = Object.keys(mocks || {});

  angular.mock.module(function ($provide) {
    mockNames.forEach(function (mockName) {
      var mockBuilder = typeof mocks[mockName] === 'function' ? mocks[mockName] : function () {
        return mocks[mockName];
      };
      $provide.factory(mockName, mockBuilder);
    });
  });

  var app = {};

  var otherNames = [].concat(_toConsumableArray(new Set([].concat(_toConsumableArray(mockNames), _toConsumableArray(access || [])))));

  angular.mock.inject(['$rootScope', '$compile'].concat(_toConsumableArray(otherNames), [function ($rootScope, $compile) {
    for (var _len = arguments.length, other = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      other[_key - 2] = arguments[_key];
    }

    app.$scope = $rootScope.$new();

    otherNames.forEach(function (name, index) {
      app[name] = other[index];
    });

    app.render = function (html) {
      return render($compile, app.$scope)(html);
    };

    app.eventually = function (fn) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var interval = config.interval || 0;
      var limit = config.limit || 10;
      return eventually(app.$scope)(fn, interval, limit);
    };
  }]));

  return app;
};